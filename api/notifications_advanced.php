<?phprequire_once 'config.php';require_once 'auth.php';class AdvancedNotificationManager {    private $db;    private $auth;        public function __construct($db) {        $this->db = $db;        $this->auth = new AuthAPI($db);    }        // Criar notificação    public function createNotification($userId, $type, $title, $message, $ticketId = null, $priority = 'normal') {        $stmt = $this->db->prepare("            INSERT INTO notifications (user_id, type, title, message, ticket_id, priority, is_read, created_at)             VALUES (?, ?, ?, ?, ?, ?, 0, NOW())        ");        return $stmt->execute([$userId, $type, $title, $message, $ticketId, $priority]);    }        // Obter notificações do usuário    public function getUserNotifications($userId, $limit = 50) {        $stmt = $this->db->prepare("            SELECT                 n.*,                t.title as ticket_title            FROM notifications n            LEFT JOIN tickets t ON n.ticket_id = t.id            WHERE n.user_id = ?            ORDER BY n.created_at DESC            LIMIT ?        ");        $stmt->execute([$userId, $limit]);        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }        // Marcar notificação como lida    public function markAsRead($notificationId, $userId) {        $stmt = $this->db->prepare("            UPDATE notifications             SET is_read = 1, read_at = NOW()             WHERE id = ? AND user_id = ?        ");        return $stmt->execute([$notificationId, $userId]);    }        // Marcar todas as notificações como lidas    public function markAllAsRead($userId) {        $stmt = $this->db->prepare("            UPDATE notifications             SET is_read = 1, read_at = NOW()             WHERE user_id = ? AND is_read = 0        ");        return $stmt->execute([$userId]);    }        // Obter contador de notificações não lidas    public function getUnreadCount($userId) {        $stmt = $this->db->prepare("            SELECT COUNT(*) as count             FROM notifications             WHERE user_id = ? AND is_read = 0        ");        $stmt->execute([$userId]);        $result = $stmt->fetch(PDO::FETCH_ASSOC);        return $result['count'];    }        // Notificar ticket criado    public function notifyTicketCreated($ticketId) {        $ticket = $this->getTicket($ticketId);        if (!$ticket) return false;                // Notificar administradores        $admins = $this->getAdmins();        foreach ($admins as $admin) {            $this->createNotification(                $admin['id'],                'ticket_created',                'Novo Ticket Criado',                "Ticket #{$ticketId} foi criado: {$ticket['title']}",                $ticketId,                'normal'            );        }                return true;    }        // Notificar ticket atribuído    public function notifyTicketAssigned($ticketId, $assignedTo) {        $ticket = $this->getTicket($ticketId);        if (!$ticket) return false;                $this->createNotification(            $assignedTo,            'ticket_assigned',            'Ticket Atribuído',            "Ticket #{$ticketId} foi atribuído a você: {$ticket['title']}",            $ticketId,            'high'        );                return true;    }        // Notificar ticket atualizado    public function notifyTicketUpdated($ticketId, $updatedBy) {        $ticket = $this->getTicket($ticketId);        if (!$ticket) return false;                // Notificar o criador do ticket        if ($ticket['created_by'] != $updatedBy) {            $this->createNotification(                $ticket['created_by'],                'ticket_updated',                'Ticket Atualizado',                "Ticket #{$ticketId} foi atualizado: {$ticket['title']}",                $ticketId,                'normal'            );        }                // Notificar o usuário atribuído        if ($ticket['assigned_to'] && $ticket['assigned_to'] != $updatedBy) {            $this->createNotification(                $ticket['assigned_to'],                'ticket_updated',                'Ticket Atualizado',                "Ticket #{$ticketId} foi atualizado: {$ticket['title']}",                $ticketId,                'normal'            );        }                return true;    }        // Notificar violação de SLA    public function notifySLAViolation($ticketId) {        $ticket = $this->getTicket($ticketId);        if (!$ticket) return false;                // Notificar o usuário atribuído        if ($ticket['assigned_to']) {            $this->createNotification(                $ticket['assigned_to'],                'sla_violation',                'SLA Violation',                "Ticket #{$ticketId} excedeu o tempo de SLA: {$ticket['title']}",                $ticketId,                'critical'            );        }                // Notificar administradores        $admins = $this->getAdmins();        foreach ($admins as $admin) {            $this->createNotification(                $admin['id'],                'sla_violation',                'SLA Violation',                "Ticket #{$ticketId} excedeu o tempo de SLA: {$ticket['title']}",                $ticketId,                'critical'            );        }                return true;    }        // Notificar comentário adicionado    public function notifyCommentAdded($ticketId, $comment, $addedBy) {        $ticket = $this->getTicket($ticketId);        if (!$ticket) return false;                // Notificar o criador do ticket        if ($ticket['created_by'] != $addedBy) {            $this->createNotification(                $ticket['created_by'],                'comment_added',                'Novo Comentário',                "Novo comentário no ticket #{$ticketId}: {$ticket['title']}",                $ticketId,                'normal'            );        }                // Notificar o usuário atribuído        if ($ticket['assigned_to'] && $ticket['assigned_to'] != $addedBy) {            $this->createNotification(                $ticket['assigned_to'],                'comment_added',                'Novo Comentário',                "Novo comentário no ticket #{$ticketId}: {$ticket['title']}",                $ticketId,                'normal'            );        }                return true;    }        // Notificar ticket fechado    public function notifyTicketClosed($ticketId, $closedBy) {        $ticket = $this->getTicket($ticketId);        if (!$ticket) return false;                // Notificar o criador do ticket        if ($ticket['created_by'] != $closedBy) {            $this->createNotification(                $ticket['created_by'],                'ticket_closed',                'Ticket Fechado',                "Ticket #{$ticketId} foi fechado: {$ticket['title']}",                $ticketId,                'normal'            );        }                return true;    }        // Obter ticket    private function getTicket($ticketId) {        $stmt = $this->db->prepare("SELECT * FROM tickets WHERE id = ?");        $stmt->execute([$ticketId]);        return $stmt->fetch(PDO::FETCH_ASSOC);    }        // Obter administradores    private function getAdmins() {        $stmt = $this->db->prepare("            SELECT u.* FROM users u            JOIN user_permissions up ON u.id = up.user_id            JOIN permissions p ON up.permission_id = p.id            WHERE p.name = 'admin'        ");        $stmt->execute();        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }        // Obter notificações por tipo    public function getNotificationsByType($userId, $type, $limit = 20) {        $stmt = $this->db->prepare("            SELECT                 n.*,                t.title as ticket_title            FROM notifications n            LEFT JOIN tickets t ON n.ticket_id = t.id            WHERE n.user_id = ? AND n.type = ?            ORDER BY n.created_at DESC            LIMIT ?        ");        $stmt->execute([$userId, $type, $limit]);        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }        // Obter notificações por prioridade    public function getNotificationsByPriority($userId, $priority, $limit = 20) {        $stmt = $this->db->prepare("            SELECT                 n.*,                t.title as ticket_title            FROM notifications n            LEFT JOIN tickets t ON n.ticket_id = t.id            WHERE n.user_id = ? AND n.priority = ?            ORDER BY n.created_at DESC            LIMIT ?        ");        $stmt->execute([$userId, $priority, $limit]);        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }        // Deletar notificação    public function deleteNotification($notificationId, $userId) {        $stmt = $this->db->prepare("            DELETE FROM notifications             WHERE id = ? AND user_id = ?        ");        return $stmt->execute([$notificationId, $userId]);    }        // Deletar notificações antigas    public function deleteOldNotifications($days = 30) {        $stmt = $this->db->prepare("            DELETE FROM notifications             WHERE created_at < DATE_SUB(NOW(), INTERVAL ? DAY)        ");        return $stmt->execute([$days]);    }        // Obter estatísticas de notificações    public function getNotificationStatistics($userId = null) {        $whereClause = "";        $params = [];                if ($userId) {            $whereClause = "WHERE user_id = ?";            $params = [$userId];        }                $stmt = $this->db->prepare("            SELECT                 COUNT(*) as total_notifications,                COUNT(CASE WHEN is_read = 0 THEN 1 END) as unread_notifications,                COUNT(CASE WHEN priority = 'critical' THEN 1 END) as critical_notifications,                COUNT(CASE WHEN type = 'ticket_created' THEN 1 END) as ticket_created_notifications,                COUNT(CASE WHEN type = 'ticket_assigned' THEN 1 END) as ticket_assigned_notifications            FROM notifications             $whereClause        ");        $stmt->execute($params);        return $stmt->fetch(PDO::FETCH_ASSOC);    }}?>