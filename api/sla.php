<?phprequire_once 'config.php';require_once 'auth.php';require_once 'notifications.php';class SLAManager {    private $db;    private $auth;    private $notifications;        public function __construct($db) {        $this->db = $db;        $this->auth = new AuthAPI($db);        $this->notifications = new NotificationManager($db);    }        // Definir SLA para categoria/prioridade    public function setSLA($category, $priority, $responseTime, $resolutionTime) {        $stmt = $this->db->prepare("            INSERT INTO sla_rules (category, priority, response_time_hours, resolution_time_hours, is_active)             VALUES (?, ?, ?, ?, 1)            ON DUPLICATE KEY UPDATE             response_time_hours = VALUES(response_time_hours),            resolution_time_hours = VALUES(resolution_time_hours),            is_active = VALUES(is_active)        ");        return $stmt->execute([$category, $priority, $responseTime, $resolutionTime]);    }        // Verificar SLA de ticket    public function checkTicketSLA($ticketId) {        $ticket = $this->getTicket($ticketId);        if (!$ticket) return false;                $slaRule = $this->getSLARule($ticket['category'], $ticket['priority']);        if (!$slaRule) return true; // Sem SLA definido                $currentTime = new DateTime();        $createdTime = new DateTime($ticket['created_at']);        $timeDiff = $currentTime->diff($createdTime);        $hoursElapsed = $timeDiff->h + ($timeDiff->days * 24);                $responseTime = $slaRule['response_time_hours'];        $resolutionTime = $slaRule['resolution_time_hours'];                $slaStatus = [            'ticket_id' => $ticketId,            'response_sla' => $hoursElapsed <= $responseTime,            'resolution_sla' => $hoursElapsed <= $resolutionTime,            'hours_elapsed' => $hoursElapsed,            'response_time_limit' => $responseTime,            'resolution_time_limit' => $resolutionTime,            'response_breach' => $hoursElapsed > $responseTime,            'resolution_breach' => $hoursElapsed > $resolutionTime        ];                // Marcar ticket se SLA foi violado        if ($slaStatus['response_breach'] || $slaStatus['resolution_breach']) {            $this->markSLAViolation($ticketId, $slaStatus);        }                return $slaStatus;    }        // Verificar SLA de todos os tickets    public function checkAllTicketsSLA() {        $stmt = $this->db->prepare("            SELECT id FROM tickets             WHERE status IN ('open', 'in_progress')             AND created_at > DATE_SUB(NOW(), INTERVAL 7 DAY)        ");        $stmt->execute();        $tickets = $stmt->fetchAll(PDO::FETCH_ASSOC);                $violations = [];        foreach ($tickets as $ticket) {            $slaStatus = $this->checkTicketSLA($ticket['id']);            if ($slaStatus['response_breach'] || $slaStatus['resolution_breach']) {                $violations[] = $slaStatus;            }        }                return $violations;    }        // Marcar violação de SLA    private function markSLAViolation($ticketId, $slaStatus) {        $stmt = $this->db->prepare("            INSERT INTO sla_violations (ticket_id, violation_type, hours_elapsed, created_at)             VALUES (?, ?, ?, NOW())            ON DUPLICATE KEY UPDATE             violation_type = VALUES(violation_type),            hours_elapsed = VALUES(hours_elapsed),            created_at = VALUES(created_at)        ");                $violationType = $slaStatus['response_breach'] ? 'response' : 'resolution';        $stmt->execute([$ticketId, $violationType, $slaStatus['hours_elapsed']]);                // Enviar notificação de violação        $this->notifySLAViolation($ticketId, $slaStatus);    }        // Notificar violação de SLA    private function notifySLAViolation($ticketId, $slaStatus) {        $ticket = $this->getTicket($ticketId);        $assignedUser = $this->getUser($ticket['assigned_to']);                if ($assignedUser) {            $subject = "SLA Violation - Ticket #{$ticketId}";            $message = "Ticket #{$ticketId} excedeu o tempo de SLA.\n";            $message .= "Tempo decorrido: {$slaStatus['hours_elapsed']} horas\n";            $message .= "Limite de resposta: {$slaStatus['response_time_limit']} horas\n";            $message .= "Limite de resolução: {$slaStatus['resolution_time_limit']} horas";                        $this->notifications->sendEmail(                $assignedUser['email'],                $subject,                $message            );        }    }        // Obter estatísticas de SLA    public function getSLAStatistics($startDate = null, $endDate = null) {        $whereClause = "";        $params = [];                if ($startDate && $endDate) {            $whereClause = "WHERE t.created_at BETWEEN ? AND ?";            $params = [$startDate, $endDate];        }                $stmt = $this->db->prepare("            SELECT                 COUNT(t.id) as total_tickets,                COUNT(CASE WHEN sv.id IS NOT NULL THEN 1 END) as sla_violations,                ROUND(                    (COUNT(CASE WHEN sv.id IS NOT NULL THEN 1 END) / COUNT(t.id)) * 100, 2                ) as violation_percentage,                AVG(TIMESTAMPDIFF(HOUR, t.created_at, t.updated_at)) as avg_resolution_time            FROM tickets t            LEFT JOIN sla_violations sv ON t.id = sv.ticket_id            $whereClause        ");        $stmt->execute($params);        return $stmt->fetch(PDO::FETCH_ASSOC);    }        // Obter relatório de SLA por categoria    public function getSLAByCategory($startDate = null, $endDate = null) {        $whereClause = "";        $params = [];                if ($startDate && $endDate) {            $whereClause = "WHERE t.created_at BETWEEN ? AND ?";            $params = [$startDate, $endDate];        }                $stmt = $this->db->prepare("            SELECT                 t.category,                COUNT(t.id) as total_tickets,                COUNT(CASE WHEN sv.id IS NOT NULL THEN 1 END) as sla_violations,                ROUND(                    (COUNT(CASE WHEN sv.id IS NOT NULL THEN 1 END) / COUNT(t.id)) * 100, 2                ) as violation_percentage,                AVG(TIMESTAMPDIFF(HOUR, t.created_at, t.updated_at)) as avg_resolution_time            FROM tickets t            LEFT JOIN sla_violations sv ON t.id = sv.ticket_id            $whereClause            GROUP BY t.category            ORDER BY violation_percentage DESC        ");        $stmt->execute($params);        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }        // Obter relatório de SLA por usuário    public function getSLAByUser($startDate = null, $endDate = null) {        $whereClause = "";        $params = [];                if ($startDate && $endDate) {            $whereClause = "WHERE t.created_at BETWEEN ? AND ?";            $params = [$startDate, $endDate];        }                $stmt = $this->db->prepare("            SELECT                 u.name as user_name,                COUNT(t.id) as total_tickets,                COUNT(CASE WHEN sv.id IS NOT NULL THEN 1 END) as sla_violations,                ROUND(                    (COUNT(CASE WHEN sv.id IS NOT NULL THEN 1 END) / COUNT(t.id)) * 100, 2                ) as violation_percentage,                AVG(TIMESTAMPDIFF(HOUR, t.created_at, t.updated_at)) as avg_resolution_time            FROM users u            LEFT JOIN tickets t ON u.id = t.assigned_to            LEFT JOIN sla_violations sv ON t.id = sv.ticket_id            $whereClause            GROUP BY u.id, u.name            ORDER BY violation_percentage DESC        ");        $stmt->execute($params);        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }        // Obter regras de SLA    public function getSLARules() {        $stmt = $this->db->prepare("SELECT * FROM sla_rules WHERE is_active = 1 ORDER BY category, priority");        $stmt->execute();        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }        // Obter regra de SLA específica    private function getSLARule($category, $priority) {        $stmt = $this->db->prepare("            SELECT * FROM sla_rules             WHERE category = ? AND priority = ? AND is_active = 1        ");        $stmt->execute([$category, $priority]);        return $stmt->fetch(PDO::FETCH_ASSOC);    }        // Obter ticket    private function getTicket($ticketId) {        $stmt = $this->db->prepare("SELECT * FROM tickets WHERE id = ?");        $stmt->execute([$ticketId]);        return $stmt->fetch(PDO::FETCH_ASSOC);    }        // Obter usuário    private function getUser($userId) {        $stmt = $this->db->prepare("SELECT * FROM users WHERE id = ?");        $stmt->execute([$userId]);        return $stmt->fetch(PDO::FETCH_ASSOC);    }        // Criar SLA padrão    public function createDefaultSLA() {        $defaultSLAs = [            ['technical', 'low', 24, 72],            ['technical', 'medium', 12, 48],            ['technical', 'high', 4, 24],            ['technical', 'critical', 1, 8],            ['billing', 'low', 48, 120],            ['billing', 'medium', 24, 72],            ['billing', 'high', 12, 48],            ['billing', 'critical', 4, 24],            ['general', 'low', 48, 120],            ['general', 'medium', 24, 72],            ['general', 'high', 12, 48],            ['general', 'critical', 6, 24]        ];                foreach ($defaultSLAs as $sla) {            $this->setSLA($sla[0], $sla[1], $sla[2], $sla[3]);        }                return true;    }        // Obter tickets próximos do SLA    public function getTicketsNearSLA($hoursBefore = 2) {        $stmt = $this->db->prepare("            SELECT                 t.*,                TIMESTAMPDIFF(HOUR, t.created_at, NOW()) as hours_elapsed,                sr.response_time_hours,                sr.resolution_time_hours            FROM tickets t            JOIN sla_rules sr ON t.category = sr.category AND t.priority = sr.priority            WHERE t.status IN ('open', 'in_progress')            AND TIMESTAMPDIFF(HOUR, t.created_at, NOW()) >= (sr.response_time_hours - ?)            AND TIMESTAMPDIFF(HOUR, t.created_at, NOW()) < sr.response_time_hours            ORDER BY hours_elapsed DESC        ");        $stmt->execute([$hoursBefore]);        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }        // Obter violações de SLA    public function getSLAViolations($startDate = null, $endDate = null) {        $whereClause = "";        $params = [];                if ($startDate && $endDate) {            $whereClause = "WHERE sv.created_at BETWEEN ? AND ?";            $params = [$startDate, $endDate];        }                $stmt = $this->db->prepare("            SELECT                 sv.*,                t.title,                t.category,                t.priority,                t.status,                u.name as assigned_user            FROM sla_violations sv            JOIN tickets t ON sv.ticket_id = t.id            LEFT JOIN users u ON t.assigned_to = u.id            $whereClause            ORDER BY sv.created_at DESC        ");        $stmt->execute($params);        return $stmt->fetchAll(PDO::FETCH_ASSOC);    }}?>