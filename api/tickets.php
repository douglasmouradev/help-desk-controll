<?php// Ativar logs de erroerror_reporting(E_ALL);ini_set('display_errors', 1);ini_set('log_errors', 1);ini_set('error_log', 'C:\xampp\htdocs\sistema-web-Controll IT\api_errors.log');require_once 'config.php';// require_once 'notifications.php'; // Temporariamente removido para debugclass TicketsController {    private $db;        public function __construct() {        $this->db = new Database();    }        public function index() {        // Temporariamente removido para debug        // $user = requireAuth();        $user = ['user_id' => 1, 'type' => 'admin']; // Usuário temporário para debug                $page = (int)($_GET['page'] ?? 1);        $limit = (int)($_GET['limit'] ?? 20);        $offset = ($page - 1) * $limit;                $filters = [            'status' => $_GET['status'] ?? '',            'priority' => $_GET['priority'] ?? '',            'category' => $_GET['category'] ?? '',            'user_id' => $_GET['user_id'] ?? '',            'assigned_to' => $_GET['assigned_to'] ?? ''        ];                try {            $conn = $this->db->getConnection();                        // Construir query baseada no tipo de usuário            $whereConditions = [];            $params = [];                        if ($user['type'] === 'user') {                $whereConditions[] = "t.user_id = ?";                $params[] = $user['user_id'];            } elseif ($user['type'] === 'support') {                // Suporte pode ver todos os chamados                $whereConditions[] = "1=1";            }                        // Aplicar filtros            if ($filters['status']) {                $whereConditions[] = "ts.slug = ?";                $params[] = $filters['status'];            }                        if ($filters['priority']) {                $whereConditions[] = "tp.name = ?";                $params[] = $filters['priority'];            }                        if ($filters['category']) {                $whereConditions[] = "tc.name = ?";                $params[] = $filters['category'];            }                        if ($filters['user_id']) {                $whereConditions[] = "t.user_id = ?";                $params[] = $filters['user_id'];            }                        if ($filters['assigned_to']) {                $whereConditions[] = "t.assigned_to = ?";                $params[] = $filters['assigned_to'];            }                        $whereClause = !empty($whereConditions) ? 'WHERE ' . implode(' AND ', $whereConditions) : '';                        // Query principal            $query = "                SELECT                     t.id, t.title, t.description, t.priority, t.status, t.category, t.created_at, t.updated_at,                    u.name as user_name, u.email as user_email,                    at.name as assigned_to_name, at.email as assigned_to_email                FROM tickets t                LEFT JOIN users u ON t.user_id = u.id                LEFT JOIN users at ON t.assigned_to = at.id                -- Removido: tabelas não existem na estrutura atual                {$whereClause}                ORDER BY t.created_at DESC                LIMIT ? OFFSET ?            ";                        $params[] = $limit;            $params[] = $offset;                        $stmt = $conn->prepare($query);            $stmt->execute($params);            $tickets = $stmt->fetchAll();                        // Contar total para paginação            $countQuery = "                SELECT COUNT(*) as total                FROM tickets t                -- Removido: tabelas não existem na estrutura atual                {$whereClause}            ";                        $countParams = array_slice($params, 0, -2); // Remove limit e offset            $countStmt = $conn->prepare($countQuery);            $countStmt->execute($countParams);            $total = $countStmt->fetch()['total'];                        $result = [                'tickets' => $tickets,                'pagination' => [                    'page' => $page,                    'limit' => $limit,                    'total' => (int)$total,                    'pages' => ceil($total / $limit)                ]            ];                        ApiResponse::success($result, 'Chamados carregados com sucesso');                    } catch (Exception $e) {            ApiResponse::error('Erro interno do servidor', 500);        }    }        public function show($id) {        // Temporariamente removido para debug        // $user = requireAuth();        $user = ['user_id' => 1, 'type' => 'admin']; // Usuário temporário para debug                try {            $conn = $this->db->getConnection();                        $query = "                SELECT                     t.id, t.title, t.description, t.priority, t.created_at, t.updated_at, t.resolved_at,                    u.name as user_name, u.email as user_email,                    at.name as assigned_to_name, at.email as assigned_to_email,                    t.category,                    t.status                FROM tickets t                LEFT JOIN users u ON t.user_id = u.id                LEFT JOIN users at ON t.assigned_to = at.id                -- Removido: tabelas não existem na estrutura atual                WHERE t.id = ?            ";                        $stmt = $conn->prepare($query);            $stmt->execute([$id]);            $ticket = $stmt->fetch();                        if (!$ticket) {                ApiResponse::notFound('Chamado não encontrado');            }                        // Verificar permissão            if ($user['type'] === 'user' && $ticket['user_id'] != $user['user_id']) {                ApiResponse::forbidden('Acesso negado a este chamado');            }                        // Por enquanto, não carregar comentários e histórico            // Isso será implementado quando as tabelas estiverem prontas                        ApiResponse::success($ticket, 'Chamado carregado com sucesso');                    } catch (Exception $e) {            ApiResponse::error('Erro interno do servidor', 500);        }    }        public function create() {        $user = requireAuth();                if ($_SERVER['REQUEST_METHOD'] !== 'POST') {            ApiResponse::error('Método não permitido', 405);        }                $input = json_decode(file_get_contents('php://input'), true);                $missing = Validator::validateRequired(['title', 'description', 'category_id', 'priority_id'], $input);        if (!empty($missing)) {            ApiResponse::error('Campos obrigatórios: ' . implode(', ', $missing), 400);        }                try {            $conn = $this->db->getConnection();                        // Verificar se categoria e prioridade existem            $categoryStmt = $conn->prepare("SELECT id FROM ticket_categories WHERE id = ? AND active = 1");            $categoryStmt->execute([$input['category_id']]);            if (!$categoryStmt->fetch()) {                ApiResponse::error('Categoria inválida', 400);            }                        $priorityStmt = $conn->prepare("SELECT id FROM ticket_priorities WHERE id = ?");            $priorityStmt->execute([$input['priority_id']]);            if (!$priorityStmt->fetch()) {                ApiResponse::error('Prioridade inválida', 400);            }                        // Status padrão (aberto)            $statusStmt = $conn->prepare("SELECT id FROM ticket_statuses WHERE slug = 'aberto'");            $statusStmt->execute();            $statusId = $statusStmt->fetch()['id'];                        // Criar chamado            $stmt = $conn->prepare("                INSERT INTO tickets (title, description, category_id, priority_id, status_id, user_id)                 VALUES (?, ?, ?, ?, ?, ?)            ");                        $stmt->execute([                Validator::sanitizeInput($input['title']),                Validator::sanitizeInput($input['description']),                $input['category_id'],                $input['priority_id'],                $statusId,                $user['user_id']            ]);                        $ticketId = $conn->lastInsertId();                        // Processar uploads de arquivos se houver            $attachments = [];            if (isset($_FILES['attachments']) && !empty($_FILES['attachments']['name'][0])) {                $attachments = $this->handleFileUploads($ticketId);            }                        // Log da atividade            logActivity($user['user_id'], 'TICKET_CREATED', $ticketId, true);                        // Enviar notificações            notifyTicketCreated($ticketId);                        // Retornar o chamado criado            $this->show($ticketId);                    } catch (Exception $e) {            logActivity($user['user_id'], 'TICKET_CREATE_ERROR', null, false);            ApiResponse::error('Erro ao criar chamado', 500);        }    }        private function handleFileUploads($ticketId) {        $attachments = [];        $conn = $this->db->getConnection();                if (!isset($_FILES['attachments']) || empty($_FILES['attachments']['name'][0])) {            return $attachments;        }                $files = $_FILES['attachments'];        $fileCount = count($files['name']);                for ($i = 0; $i < $fileCount; $i++) {            if ($files['error'][$i] === UPLOAD_ERR_OK) {                try {                    $file = [                        'name' => $files['name'][$i],                        'type' => $files['type'][$i],                        'tmp_name' => $files['tmp_name'][$i],                        'error' => $files['error'][$i],                        'size' => $files['size'][$i]                    ];                                        $uploadResult = handleFileUpload($file, $ticketId);                                        // Salvar informações do arquivo no banco                    $stmt = $conn->prepare("                        INSERT INTO ticket_attachments (ticket_id, filename, original_filename, file_path, file_size, mime_type)                         VALUES (?, ?, ?, ?, ?, ?)                    ");                                        $stmt->execute([                        $ticketId,                        $uploadResult['filename'],                        $uploadResult['original_filename'],                        $uploadResult['file_path'],                        $uploadResult['file_size'],                        $uploadResult['mime_type']                    ]);                                        $attachments[] = [                        'id' => $conn->lastInsertId(),                        'filename' => $uploadResult['filename'],                        'original_filename' => $uploadResult['original_filename'],                        'file_size' => $uploadResult['file_size'],                        'mime_type' => $uploadResult['mime_type']                    ];                                    } catch (Exception $e) {                    error_log("Erro no upload do arquivo: " . $e->getMessage());                    // Continuar com outros arquivos mesmo se um falhar                }            }        }                return $attachments;    }        public function update($id) {        $user = requireAuth();                if ($_SERVER['REQUEST_METHOD'] !== 'PUT') {            ApiResponse::error('Método não permitido', 405);        }                $input = json_decode(file_get_contents('php://input'), true);                try {            $conn = $this->db->getConnection();                        // Verificar se o chamado existe            $stmt = $conn->prepare("SELECT * FROM tickets WHERE id = ?");            $stmt->execute([$id]);            $ticket = $stmt->fetch();                        if (!$ticket) {                ApiResponse::notFound('Chamado não encontrado');            }                        // Verificar permissões            if ($user['type'] === 'user' && $ticket['user_id'] != $user['user_id']) {                ApiResponse::forbidden('Acesso negado');            }                        $updates = [];            $params = [];                        // Campos que podem ser atualizados            $allowedFields = ['title', 'description', 'priority_id', 'status_id', 'assigned_to'];                        foreach ($allowedFields as $field) {                if (isset($input[$field])) {                    $oldValue = $ticket[$field];                    $newValue = $input[$field];                                        if ($oldValue != $newValue) {                        $updates[] = "{$field} = ?";                        $params[] = $newValue;                                                // Log da mudança                        $historyStmt = $conn->prepare("                            INSERT INTO ticket_history (ticket_id, user_id, field_name, old_value, new_value)                             VALUES (?, ?, ?, ?, ?)                        ");                        $historyStmt->execute([                            $id,                             $user['user_id'],                             $field,                             $oldValue,                             $newValue                        ]);                    }                }            }                        if (!empty($updates)) {                $params[] = $id;                $updateQuery = "UPDATE tickets SET " . implode(', ', $updates) . ", updated_at = CURRENT_TIMESTAMP WHERE id = ?";                                $updateStmt = $conn->prepare($updateQuery);                $updateStmt->execute($params);                                // Se mudou para status fechado, definir closed_at                if (isset($input['status_id'])) {                    $statusStmt = $conn->prepare("SELECT slug FROM ticket_statuses WHERE id = ?");                    $statusStmt->execute([$input['status_id']]);                    $status = $statusStmt->fetch();                                        if ($status && $status['slug'] === 'fechado') {                        $closeStmt = $conn->prepare("UPDATE tickets SET closed_at = CURRENT_TIMESTAMP WHERE id = ?");                        $closeStmt->execute([$id]);                    }                }                                logActivity($user['user_id'], 'TICKET_UPDATED', $id, true);                                // Enviar notificação se houve mudanças                if (!empty($updates)) {                    $changes = implode(', ', array_keys($updates));                    notifyTicketUpdated($id, $changes);                }            }                        // Retornar o chamado atualizado            $this->show($id);                    } catch (Exception $e) {            logActivity($user['user_id'], 'TICKET_UPDATE_ERROR', $id, false);            ApiResponse::error('Erro ao atualizar chamado', 500);        }    }        public function delete($id) {        requirePermission('admin');                if ($_SERVER['REQUEST_METHOD'] !== 'DELETE') {            ApiResponse::error('Método não permitido', 405);        }                try {            $conn = $this->db->getConnection();                        // Verificar se o chamado existe            $stmt = $conn->prepare("SELECT id FROM tickets WHERE id = ?");            $stmt->execute([$id]);                        if (!$stmt->fetch()) {                ApiResponse::notFound('Chamado não encontrado');            }                        // Deletar chamado (cascade vai deletar comentários e histórico)            $deleteStmt = $conn->prepare("DELETE FROM tickets WHERE id = ?");            $deleteStmt->execute([$id]);                        logActivity($_SESSION['user_id'] ?? null, 'TICKET_DELETED', $id, true);                        ApiResponse::success(null, 'Chamado excluído com sucesso');                    } catch (Exception $e) {            ApiResponse::error('Erro ao excluir chamado', 500);        }    }        public function addComment($id) {        $user = requireAuth();                if ($_SERVER['REQUEST_METHOD'] !== 'POST') {            ApiResponse::error('Método não permitido', 405);        }                $input = json_decode(file_get_contents('php://input'), true);                $missing = Validator::validateRequired(['comment'], $input);        if (!empty($missing)) {            ApiResponse::error('Campos obrigatórios: ' . implode(', ', $missing), 400);        }                try {            $conn = $this->db->getConnection();                        // Verificar se o chamado existe            $stmt = $conn->prepare("SELECT id FROM tickets WHERE id = ?");            $stmt->execute([$id]);                        if (!$stmt->fetch()) {                ApiResponse::notFound('Chamado não encontrado');            }                        // Adicionar comentário            $commentStmt = $conn->prepare("                INSERT INTO ticket_comments (ticket_id, user_id, comment, is_internal)                 VALUES (?, ?, ?, ?)            ");                        $isInternal = $input['is_internal'] ?? false;            $commentStmt->execute([                $id,                $user['user_id'],                Validator::sanitizeInput($input['comment']),                $isInternal ? 1 : 0            ]);                        logActivity($user['user_id'], 'COMMENT_ADDED', $id, true);                        ApiResponse::success(null, 'Comentário adicionado com sucesso');                    } catch (Exception $e) {            ApiResponse::error('Erro ao adicionar comentário', 500);        }    }        public function getStats() {        $user = requireAuth();                try {            $conn = $this->db->getConnection();                        $stats = [];                        if ($user['type'] === 'user') {                // Estatísticas do usuário                $stmt = $conn->prepare("                    SELECT                         COUNT(*) as total,                        COUNT(CASE WHEN ts.slug = 'aberto' THEN 1 END) as open,                        COUNT(CASE WHEN ts.slug = 'em_andamento' THEN 1 END) as in_progress,                        COUNT(CASE WHEN ts.is_final = 1 THEN 1 END) as closed                    FROM tickets t                    LEFT JOIN ticket_statuses ts ON t.status_id = ts.id                    WHERE t.user_id = ?                ");                $stmt->execute([$user['user_id']]);                $stats = $stmt->fetch();                            } elseif ($user['type'] === 'support') {                // Estatísticas do suporte                $stmt = $conn->prepare("                    SELECT                         COUNT(CASE WHEN ts.slug = 'aberto' THEN 1 END) as open_tickets,                        COUNT(CASE WHEN t.assigned_to = ? THEN 1 END) as assigned_to_me,                        COUNT(CASE WHEN ts.slug = 'em_andamento' AND t.assigned_to = ? THEN 1 END) as in_progress,                        COUNT(CASE WHEN ts.is_final = 1 AND t.assigned_to = ? THEN 1 END) as closed                    FROM tickets t                    LEFT JOIN ticket_statuses ts ON t.status_id = ts.id                ");                $stmt->execute([$user['user_id'], $user['user_id'], $user['user_id']]);                $stats = $stmt->fetch();                            } else {                // Estatísticas administrativas                $stmt = $conn->prepare("                    SELECT                         COUNT(t.id) as total_tickets,                        COUNT(u.id) as total_users,                        COUNT(CASE WHEN u.user_type = 'support' THEN 1 END) as support_users,                        AVG(CASE                             WHEN t.closed_at IS NOT NULL THEN                                 TIMESTAMPDIFF(HOUR, t.created_at, t.closed_at)                            ELSE NULL                         END) as avg_resolution_time                    FROM tickets t                    CROSS JOIN users u                ");                $stmt->execute();                $stats = $stmt->fetch();            }                        ApiResponse::success($stats, 'Estatísticas carregadas com sucesso');                    } catch (Exception $e) {            ApiResponse::error('Erro interno do servidor', 500);        }    }}// Roteamento$controller = new TicketsController();$method = $_SERVER['REQUEST_METHOD'] ?? 'GET';$path = $_GET['path'] ?? '';// Extrair ID da URL se presente$id = null;if (preg_match('/\/(\d+)/', $path, $matches)) {    $id = $matches[1];}switch ($method) {    case 'GET':        if ($id) {            $controller->show($id);        } elseif (strpos($path, 'stats') !== false) {            $controller->getStats();        } else {            $controller->index();        }        break;    case 'POST':        if ($id && strpos($path, 'comment') !== false) {            $controller->addComment($id);        } else {            $controller->create();        }        break;    case 'PUT':        if ($id) {            $controller->update($id);        } else {            ApiResponse::error('ID do chamado não fornecido', 400);        }        break;    case 'DELETE':        if ($id) {            $controller->delete($id);        } else {            ApiResponse::error('ID do chamado não fornecido', 400);        }        break;    default:        ApiResponse::error('Método não permitido', 405);}?>